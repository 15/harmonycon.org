---
const { title } = Astro.props;
import { getImage } from "astro:assets";
import Exit from "../components/Exit.astro";

import curtains1 from "../assets/2025/curtain_full.png";
const optimizedCurtains1 = await getImage({
  src: curtains1,
  format: "avif",
  width: 400,
});

import curtains2 from "../assets/2025/curtain_fall.png";
const optimizedCurtains2 = await getImage({
  src: curtains2,
  format: "avif",
  width: 1400,
});

import indexBackground from "../assets/2025/bg/stage3.png";
const optimizedIndexBackground = await getImage({
  src: indexBackground,
  format: "avif",
  width: 800,
});

import mainBackground from "../assets/2025/bg/bricks.jpg";
const optimizedMainBackground = await getImage({
  src: mainBackground,
  format: "avif",
  width: 600,
});

import creditsBackground from "../assets/2025/bg/terrazzo-transformed.jpg";
const optimizedCreditsBackground = await getImage({
  src: creditsBackground,
  format: "avif",
  width: 1000,
});

import applyBackground from "../assets/2025/bg/stage2.png";
const optimizedApplyBackground = await getImage({
  src: applyBackground,
  format: "avif",
  width: 1400,
});

import clipboard from "../assets/2025/clipboardhoof2.png";
const optimizedClipboard = await getImage({
  src: clipboard,
  format: "avif",
  width: 1000,
});

import cocBackground from "../assets/2025/bg/wood-black.jpg";
const optimizedCocBackground = await getImage({
  src: cocBackground,
  format: "avif",
  width: 2000,
});

import registerBackground from "../assets/2025/bg/bar_final_2.png";
const optimizedRegisterBackground = await getImage({
  src: registerBackground,
  format: "avif",
  width: 1000,
});

import galleryBackground from "../assets/2025/marble.webp";
const optimizedGalleryBackground = await getImage({
  src: galleryBackground,
  format: "avif",
  width: 1000,
});

import tune from "../assets/2025/tune1.png";
const optimizedTune = await getImage({
  src: tune,
  format: "avif",
  width: 600,
});

import star from "../assets/2025/star1.png";
const optimizedStar = await getImage({
  src: star,
  format: "avif",
  width: 600,
});

import logo from "../assets/2025/logowithdates.png";
const optimizedLogo = await getImage({
  src: logo,
  format: "avif",
  width: 1000,
});

const { pathname } = Astro.url;
---

<!doctype html>
<html lang="en">
  <head>
    <!-- Google tag (gtag.js) -->
    <script
      type="text/partytown"
      async
      src="https://www.googletagmanager.com/gtag/js?id=G-GHFYSZQDXC"> </script>
    <script type="text/partytown">
      window.dataLayer = window.dataLayer || [];
      function gtag() {
        dataLayer.push(arguments);
      }
      gtag("js", new Date());

      gtag("config", "G-GHFYSZQDXC");
    </script>
    <meta charset="UTF-8" />
    <meta property="og:title" content="HarmonyCon 2025" />
    <meta
      property="og:description"
      content="Curtains up — HarmonyCon brings the magic of musical theater to life from January 31st to February 2nd, 2025, at the Hyatt Regency Dallas! Join us for a star-studded weekend filled with community panels, special guests, lively events, and unforgettable evenings of Coltchella and an enchanting Manesquerade, all celebrating the magic of friendship!"
    />
    <meta property="og:image" content="/flyer.png" />
    <meta property="og:image:width" content="4500" />
    <meta property="og:image:height" content="3000" />
    <meta property="og:url" content="https://harmonycon.org" />
    <meta property="og:type" content="website" />
    <meta property="og:site_name" content="HarmonyCon 2025" />
    <meta property="og:image:alt" content="HarmonyCon flyer" />
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="HarmonyCon 2025" />
    <meta
      name="twitter:description"
      content="Curtains up — HarmonyCon brings the magic of musical theater to life from January 31st to February 2nd, 2025, at the Hyatt Regency Dallas! Join us for a star-studded weekend filled with community panels, special guests, lively events, and unforgettable evenings of Coltchella and an enchanting Mare-squerade, all celebrating the magic of friendship!"
    />
    <meta name="twitter:image" content="/flyer.png" />
    <meta
      name="description"
      content="Curtains up — HarmonyCon brings the magic of musical theater to life from January 31st to February 2nd, 2025, at the Hyatt Regency Dallas! Join us for a star-studded weekend filled with community panels, special guests, lively events, and unforgettable evenings of Coltchella and an enchanting Mare-squerade, all celebrating the magic of friendship!"
    />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="icon" href="/logo/favicon.ico" />
    <meta name="generator" content={Astro.generator} />
    <title>{title}</title>
    <link
      rel="preload"
      href={optimizedCurtains1.src}
      as="image"
      fetchpriority="high"
    />
    <link
      rel="preload"
      href={optimizedIndexBackground.src}
      as="image"
      fetchpriority="high"
    />
    <link
      rel="preload"
      href={optimizedTune.src}
      as="image"
      fetchpriority="high"
    />
    <link
      rel="preload"
      href={optimizedStar.src}
      as="image"
      fetchpriority="high"
    />
    <link
      rel="preload"
      href={optimizedLogo.src}
      as="image"
      fetchpriority="high"
    />
    <link
      rel="preload"
      href={optimizedCurtains2.src}
      as="image"
      fetchpriority="high"
    />
    <link
      rel="preload"
      href={optimizedCreditsBackground.src}
      as="image"
      fetchpriority="low"
    />
    <link
      rel="preload"
      href={optimizedMainBackground.src}
      as="image"
      fetchpriority="low"
    />
    <link
      rel="preload"
      href={optimizedApplyBackground.src}
      as="image"
      fetchpriority="low"
    />
    <link
      rel="preload"
      href={optimizedClipboard.src}
      as="image"
      fetchpriority="low"
    />
    <link
      rel="preload"
      href={optimizedCocBackground.src}
      as="image"
      fetchpriority="low"
    />
    <link
      rel="preload"
      href={optimizedRegisterBackground.src}
      as="image"
      fetchpriority="low"
    />
    <link
      rel="preload"
      href={optimizedGalleryBackground.src}
      as="image"
      fetchpriority="low"
    />

    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;500;600;700"
      rel="stylesheet"
    />

    <link
      href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@300;400;500;600;700"
      rel="stylesheet"
    />

    <link
      rel="preload"
      href="/fonts/Latin CG Bold Regular.otf"
      as="font"
      type="font/otf"
      crossorigin
    />
  </head>
  <body class={`m-0 p-0 min-h-svh h-auto overflow-x-hidden`}>
    <div class="whitespace-nowrap uppercase attendees p-1 md:p-2 rounded-lg absolute text-base md:text-xl top-1 md:top-4 md:right-4 inset-x-0 md:inset-x-auto mx-2 md:mx-0 font-serif text-red-500 z-40 text-center md:text-left" style="text-shadow: 2px 2px 1px #000;">
      HC25 LIVE ATTENDEE COUNT: <span class="text-red-600 font-bold text-lg md:text-2xl">1,288</span>
    </div>
    <main id="swup">
      {!["/"].includes(pathname) ? <Exit /> : null}
      <slot />
    </main>
  </body>
</html>

<style
  is:global
  define:vars={{
    optimizedCurtains1: `url(${optimizedCurtains1.src})`,
    optimizedCurtains2: `url(${optimizedCurtains2.src})`,
  }}
>
.attendees {
    background: rgba(0, 0, 0, 0.2);
    backdrop-filter: blur(8px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    box-shadow: 0 4px 30px rgba(0, 0, 0, 0.1);
  }

  :root {
    color-scheme: dark;
  }

  @font-face {
    font-family: "Latin CG Bold";
    src: local("/fonts/Latin CG Bold Regular.otf"),
      url("/fonts/Latin CG Bold Regular.otf");
    font-weight: normal;
    font-style: normal;
  }

  html {
    @apply m-0 p-0;
    --swup-overlay-theme-color: #771c2a;
    --swup-overlay-theme-duration: 0.6s;
    --swup-overlay-theme-delay: 0.2s;
    --swup-overlay-theme-scale: 1;
    --swup-overlay-theme-skew: 0deg;

    scrollbar-width: thin;
    scrollbar-color: #771c2a #151515;
    /* scrollbar-gutter: stable; */
    /* scrollbar-color: #eaeaea #771c2a; */
  }

  body {
    @apply m-0 p-0;
  }

  html.is-changing .swup-transition-overlay {
    opacity: 1;
    transition: transform var(--swup-overlay-theme-duration)
      var(--swup-overlay-theme-delay);
  }

  @media (max-width: 768px) {
    html,
    body {
      overscroll-behavior-x: auto;
      overscroll-behavior-y: auto;
    }

    .swup-transition-overlay {
      background: linear-gradient(
        45deg,
        rgb(0, 0, 0),
        rgb(0, 0, 0),
        rgb(0, 0, 0)
      );
      background-image: var(--optimizedCurtains2);
      background-size: cover;
      background-repeat: no-repeat;
    }
  }

  @media (min-width: 768px) {
    html,
    body {
      overscroll-behavior-x: none;
      overscroll-behavior-y: none;
    }

    .swup-transition-overlay {
      background: linear-gradient(
        45deg,
        rgb(0, 0, 0),
        rgb(0, 0, 0),
        rgb(0, 0, 0)
      );
      background-image: var(--optimizedCurtains2);
      background-size: cover;
      background-repeat: no-repeat;
    }
  }

  .swup-transition-overlay[data-direction="to-top"],
  .swup-transition-overlay[data-direction="to-bottom"] {
    --swup-overlay-x-scale: 1;
    --swup-overlay-y-scale: 1.2;
  }

  .swup-transition-overlay[data-direction="to-bottom"] {
    transform: translate3d(
        0,
        calc(-1 * var(--swup-overlay-transform-y-value)),
        0
      )
      skewY(var(--swup-overlay-skew-value));
  }

  html.is-animating .swup-transition-overlay[data-direction="to-bottom"] {
    transform: translate3d(0, 0, 0) skewY(var(--swup-overlay-skew-value));
  }

  html.is-rendering .swup-transition-overlay[data-direction="to-bottom"] {
    transform: translate3d(
        0,
        calc(-1 * var(--swup-overlay-transform-y-value)),
        0
      )
      skewY(var(--swup-overlay-skew-value));
  }

  html,
  body {
    -moz-user-select: -moz-none;
    -khtml-user-select: none;
    -webkit-user-select: none;

    -ms-user-select: none;
    user-select: none;
  }
</style>

<script>
  import lightGallery from "lightgallery";
  import lgThumbnail from "lightgallery/plugins/thumbnail";
  import lgZoom from "lightgallery/plugins/zoom";
  let gallery;
  import { Howl } from "howler";

  // import tippy from "tippy.js";
  // import "tippy.js/dist/tippy.css";
  // import "tippy.js/animations/shift-away-extreme.css";

  // if (!window.location.pathname.includes("/main")) {
  //   window.scrollTo(0, 0);
  // }

  document.addEventListener("swup:enable", () => {
    if (
      window.location.pathname.includes("gallery") &&
      document.getElementById("lightgallery") &&
      !gallery
    ) {
      gallery = lightGallery(document.getElementById("lightgallery"), {
        plugins: [lgZoom, lgThumbnail],
        speed: 500,
        licenseKey: import.meta.env.PUBLIC_KEY,
        mobileSettings: {
          controls: false,
          showCloseIcon: true,
          download: true,
        },
      });
    }

    window.swup.hooks.on("content:replace", () => {
      const snoot = document.getElementById("snoot");
      if (window.location.pathname.includes("register") && snoot) {
        const boop = new Howl({
          src: ["/audio/boop.wav"],
          volume: 0.15,
        });

        snoot.addEventListener("click", () => {
          boop.play();
        });

        // [0, 1, 2, 3, 4, 5, 6, 7, 8, 9].forEach((i) => {
        //   const r = document.getElementById(`register-${i}`);
        //   const instance = tippy(r, {
        //     content: `Registration opens on <span class='font-semibold'>August 12, 2024</span>!</span>`,
        //     placement: "left",
        //     animation: "shift-away-extreme",
        //     allowHTML: true,
        //     triggerTarget: document.getElementById(`${i}`),
        //   });

        //   document.getElementById("menu").addEventListener("scroll", () => {
        //     instance.hide(0);
        //   });
        // });
      }

      if (screen.width > 768 && window.location.pathname.includes("main")) {
        initLoop();
      }

      if (window.location.pathname.includes("gallery")) {
        gallery = lightGallery(document.getElementById("lightgallery"), {
          plugins: [lgZoom, lgThumbnail],
          speed: 500,
          licenseKey: import.meta.env.PUBLIC_KEY,
          mobileSettings: {
            controls: false,
            showCloseIcon: true,
            download: true,
          },
        });
      }

      if (window.location.pathname.includes("main")) {
        if (gallery) {
          gallery.destroy();
        }
      }
    });
  });

  import { gsap } from "gsap";
  import { Observer } from "gsap/Observer";
  gsap.registerPlugin(Observer);

  let deltaXTotal = 0;
  let isUpdatingBackground = false;

  const throttle = (func, limit) => {
    let inThrottle = false;
    return function (...args) {
      if (!inThrottle) {
        func.apply(this, args);
        inThrottle = true;
        setTimeout(() => {
          inThrottle = false;
        }, limit);
      }
    };
  };

  const updateBackgroundPosition = (delta) => {
    deltaXTotal += delta;
    gsap.to("#bg", {
      backgroundPositionX: `${deltaXTotal * -5.07}px`,
      duration: 0.5,
      ease: "power2.out",
      onComplete: () => {
        isUpdatingBackground = false; // Reset the flag when the animation completes
      },
    });
  };

  const throttledUpdateBackgroundPosition = throttle(
    updateBackgroundPosition,
    125
  );

  // window.addEventListener("wheel", (e) => {
  //   console.log(e.deltaY);
  //   e.preventDefault();
  //   throttledUpdateBackgroundPosition(e.deltaY);
  // });

  const initLoop = () => {
    // document.getElementById("bg").style.backgroundPositionX = "0px";
    // document.getElementById("bg").style.backgroundPositionY = "0px";
    // deltaXTotal = 0;
    let loop = horizontalLoop(".playbills li", { repeat: -1, speed: 0.3 });
    // create a tween that'll always decelerate the timeScale of the timeline back to 0 over the course of 0.5 seconds (or whatever)
    let slow = gsap.to(loop, { timeScale: 0, duration: 0.5 });
    // make the loop stopped initially.
    loop.timeScale(0);

    // now use an Observer to listen to pointer/touch/wheel events and set the timeScale of the infinite looping timeline accordingly.
    Observer.create({
      target: "#bg",
      type: "pointer,touch,wheel",
      wheelSpeed: -1,
      onChange: (self) => {
        const delta =
          Math.abs(self.deltaX) > Math.abs(self.deltaY)
            ? -self.deltaX
            : -self.deltaY;
        const adjustedDelta = delta * (self.event.type === "wheel" ? 1 : 5);
        loop.timeScale(adjustedDelta);
        // throttledUpdateBackgroundPosition(delta);
        slow.invalidate().restart(); // now decelerate
      },
    });

    let scrollPosition = 0;

    window.addEventListener("wheel", (event) => {
      let delta = event.deltaY || event.detail || event.wheelDelta;
      scrollPosition += Math.abs(delta) * 0.8;
      if (scrollPosition < 1500 && document.getElementById("scroll")) {
        gsap.to("#scroll", {
          y: scrollPosition,
          ease: "power1.out",
          duration: 0.5,
        });
      }
    });
  };

  if (screen.width > 768 && window.location.pathname.includes("main")) {
    initLoop();
  }

  /*
This helper function makes a group of elements animate along the x-axis in a seamless, responsive loop.

Features:
 - Uses xPercent so that even if the widths change (like if the window gets resized), it should still work in most cases.
 - When each item animates to the left or right enough, it will loop back to the other side
 - Optionally pass in a config object with values like "speed" (default: 1, which travels at roughly 100 pixels per second), paused (boolean),  repeat, reversed, and paddingRight.
 - The returned timeline will have the following methods added to it:
   - next() - animates to the next element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.
   - previous() - animates to the previous element using a timeline.tweenTo() which it returns. You can pass in a vars object to control duration, easing, etc.
   - toIndex() - pass in a zero-based index value of the element that it should animate to, and optionally pass in a vars object to control duration, easing, etc. Always goes in the shortest direction
   - current() - returns the current index (if an animation is in-progress, it reflects the final index)
   - times - an Array of the times on the timeline where each element hits the "starting" spot. There's also a label added accordingly, so "label1" is when the 2nd element reaches the start.
 */
  function horizontalLoop(items, config) {
    items = gsap.utils.toArray(items);
    config = config || {};
    let tl = gsap.timeline({
        repeat: config.repeat,
        paused: config.paused,
        defaults: { ease: "none" },
        onReverseComplete: () =>
          tl.totalTime(tl.rawTime() + tl.duration() * 100),
      }),
      length = items.length,
      startX = items[0].offsetLeft,
      times = [],
      widths = [],
      xPercents = [],
      curIndex = 0,
      pixelsPerSecond = (config.speed || 1) * 100,
      snap =
        config.snap === false ? (v) => v : gsap.utils.snap(config.snap || 1), // some browsers shift by a pixel to accommodate flex layouts, so for example if width is 20% the first element's width might be 242px, and the next 243px, alternating back and forth. So we snap to 5 percentage points to make things look more natural
      totalWidth,
      curX,
      distanceToStart,
      distanceToLoop,
      item,
      i;
    gsap.set(items, {
      // convert "x" to "xPercent" to make things responsive, and populate the widths/xPercents Arrays to make lookups faster.
      xPercent: (i, el) => {
        let w = (widths[i] = parseFloat(gsap.getProperty(el, "width", "px")));
        xPercents[i] = snap(
          (parseFloat(gsap.getProperty(el, "x", "px")) / w) * 100 +
            gsap.getProperty(el, "xPercent")
        );
        return xPercents[i];
      },
    });
    gsap.set(items, { x: 0 });
    totalWidth =
      items[length - 1].offsetLeft +
      (xPercents[length - 1] / 100) * widths[length - 1] -
      startX +
      items[length - 1].offsetWidth *
        gsap.getProperty(items[length - 1], "scaleX") +
      (parseFloat(config.paddingRight) || 0);
    for (i = 0; i < length; i++) {
      item = items[i];
      curX = (xPercents[i] / 100) * widths[i];
      distanceToStart = item.offsetLeft + curX - startX;
      distanceToLoop =
        distanceToStart + widths[i] * gsap.getProperty(item, "scaleX");
      tl.to(
        item,
        {
          xPercent: snap(((curX - distanceToLoop) / widths[i]) * 100),
          duration: distanceToLoop / pixelsPerSecond,
        },
        0
      )
        .fromTo(
          item,
          {
            xPercent: snap(
              ((curX - distanceToLoop + totalWidth) / widths[i]) * 100
            ),
          },
          {
            xPercent: xPercents[i],
            duration:
              (curX - distanceToLoop + totalWidth - curX) / pixelsPerSecond,
            immediateRender: false,
          },
          distanceToLoop / pixelsPerSecond
        )
        .add("label" + i, distanceToStart / pixelsPerSecond);
      times[i] = distanceToStart / pixelsPerSecond;
    }

    function toIndex(index, vars) {
      vars = vars || {};
      Math.abs(index - curIndex) > length / 2 &&
        (index += index > curIndex ? -length : length); // always go in the shortest direction
      let newIndex = gsap.utils.wrap(0, length, index),
        time = times[newIndex];
      if (time > tl.time() !== index > curIndex) {
        // if we're wrapping the timeline's playhead, make the proper adjustments
        vars.modifiers = { time: gsap.utils.wrap(0, tl.duration()) };
        time += tl.duration() * (index > curIndex ? 1 : -1);
      }
      curIndex = newIndex;
      vars.overwrite = true;
      return tl.tweenTo(time, vars);
    }
    tl.next = (vars) => toIndex(curIndex + 1, vars);
    tl.previous = (vars) => toIndex(curIndex - 1, vars);
    tl.current = () => curIndex;
    tl.toIndex = (index, vars) => toIndex(index, vars);
    tl.times = times;
    tl.progress(1, true).progress(0, true); // pre-render for performance
    if (config.reversed) {
      tl.vars.onReverseComplete();
      tl.reverse();
    }
    return tl;
  }
</script>
