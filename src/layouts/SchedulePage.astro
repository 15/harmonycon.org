---
import { Image, getImage } from "astro:assets";
import Schedule from "@layouts/Schedule.astro";
import Room from "@components/schedule/Room.astro";

import roomEmpty from "@assets/2025/schedule/room-empty.png";

// noinspection JSUnusedGlobalSymbols
interface Props {
  day: DayOfTheWeek;
  starttime: string;
  endtime: string;
  additionalevents?: { [key: string]: string }
}

const {
  day = "Friday",
  starttime: START_TIME = "10:00",
  endtime: END_TIME = "04:00",
  additionalevents = {}
} = Astro.props

export type DayOfTheWeek = "Monday" | "Tuesday" | "Wednesday" | "Thursday" | "Friday" | "Saturday" | "Sunday";

export enum ROOM {
  A = 0,
  B = 1,
  C = 2,
  D = 3,
  E = 4,
  F = 5,
  G = 6,
  H = 7,
  UNKNOWN = 8,
}

export type Event = {
  placeholder?: false;
  title: string;
  host: string;
  description: string;
  startDate: Date;
  start: string;
  endDate: Date;
  end: string;
  day: DayOfTheWeek;
  timeslots: number;
  room: ROOM;
  isConcert: boolean;
}
export type PlaceholderEvent = {
  placeholder: true,
  timeslots: number,
  startDate: Date,
}

const convertTime = (d: Date) => {
  const hours = d.getHours();
  let hString = hours.toString().padStart(2, "0");
  let suffix = "";
  const mString = d.getMinutes().toString().padStart(2, "0");
  if (hours === 0) {
    hString = "12";
    suffix = "AM";
  } else if (hours < 12) {
    suffix = "AM";
  } else if (hours === 12) {
    suffix = "PM";
  } else {
    hString = (hours - 12).toString().padStart(2, "0");
    suffix = "PM";
  }

  return `${hString}:${mString} ${suffix}`;
}



function fetchEvents() {
  interface RawEvent {
    "application-name": string;
    "start-time": string;
    "end-time": string;
    "business-name": string;
    "Panel description"?: string[];
    "Set description"?: string[];
    "Rate your panel"?: string[];
    "room-or-table-id": string;
  }

  const events = [].map((rawEvents : RawEvent[]) => {
    try {
      return rawEvents.map(ev => {
        const start = new Date(ev["start-time"]);
        const end = new Date(ev["end-time"]);
        return {
          title: ev["application-name"],
          host: ev["business-name"],
          description: (ev["Panel description"] || ev["Set description"])?.join("\n") || "",
          startDate: start,
          start: convertTime(start),
          endDate: end,
          end: convertTime(end),
          timeslots: Math.round((end.getTime() - start.getTime()) / (30 * 60 * 1000)),
          day: (() => {
            const dClone = new Date(start.getTime());
            dClone.setHours(dClone.getHours() - 6); // Offset by 6 hours to make sure events past 12AM are still counted on this day
            return ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"][dClone.getDay()] as DayOfTheWeek;
          })(),
          room: (() => {
            switch (ev["room-or-table-id"]) {
              case "A":
                return ROOM.A;
              case "B":
                return ROOM.B;
              case "C":
                return ROOM.C;
              case "D":
                return ROOM.D;
              case "E":
                return ROOM.E;
              case "F":
                return ROOM.F;
              case "G":
                return ROOM.G;
              default:
                return ROOM.UNKNOWN;
            }
          })(),
          isConcert: ev["room-or-table-id"] === "Concert"
        }
      });
    } catch (error) {
      console.warn(error);
      return [];
    }
  })
  return events.flat();
};

const remoteEvents = fetchEvents().filter(event => {
  if (event.day === day) return true;
  else return false;
});
remoteEvents.sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

const events: {[key: number]: (Event|PlaceholderEvent)[]} = {
  [ROOM.A]: [],
  [ROOM.B]: [],
  [ROOM.C]: [],
  [ROOM.D]: [],
  [ROOM.E]: [],
  [ROOM.F]: [],
  [ROOM.G]: [],
};
remoteEvents.forEach(event => {
  if (Array.isArray(events[event.room])) events[event.room].push(event);
});

Object.keys(events).forEach(room => {
  const placeholderEvents: PlaceholderEvent[] = [];
  events[room].forEach((event: Event, index, evs) => {
    if (index === (events[room].length - 1)) return;
    const nextEvent: Event = evs[index + 1];
    placeholderEvents.push({
      placeholder: true,
      startDate: event.endDate,
      timeslots: Math.round((nextEvent.startDate.getTime() - event.endDate.getTime()) / (30 * 60 * 1000))
    });
  });
  {
    const firstEvent: Event | undefined = events[room][0];
    if (firstEvent) {
      const fEStartDate = firstEvent.startDate;
      const startDate = new Date(`${fEStartDate.getFullYear()}-${fEStartDate.getMonth() + 1}-${fEStartDate.getDate()} ${START_TIME}:00`);
      placeholderEvents.push({
        placeholder: true,
        startDate,
        timeslots: Math.round((fEStartDate.getTime() - startDate.getTime()) / (30 * 60 * 1000))
      });
    }
  }
  {
    const lastEvent: Event | undefined = events[room][events[room].length - 1];
    if (lastEvent) {
      const fEEndDate = lastEvent.endDate;
      const startDate = new Date(`${fEEndDate.getFullYear()}-${fEEndDate.getMonth() + 1}-${fEEndDate.getDate() + (
        (parseInt(END_TIME) <= 10 && fEEndDate.getHours() >= 10) ? 1 : 0
      )} ${END_TIME}:00`);
      placeholderEvents.push({
        placeholder: true,
        startDate,
        timeslots: Math.round((startDate.getTime() - fEEndDate.getTime()) / (30 * 60 * 1000))
      });
    }
  }
  if (events[room].length === 0) {
    placeholderEvents.push({
      placeholder: true,
      timeslots: 1000,
      startDate: new Date(`${remoteEvents[0]?.startDate.getFullYear()}-${remoteEvents[0]?.startDate.getDate()}-${remoteEvents[0]?.startDate.getMonth() + 1} ${START_TIME}`)
    });
  }
  events[room] = events[room].concat(
    placeholderEvents.filter(event => event.timeslots > 0)
  );
  events[room].sort((a, b) => a.startDate.getTime() - b.startDate.getTime());

});
---
<Schedule day={day} additionalevents={additionalevents}>
  <Room
    roomname="A"
    roomsrc={roomEmpty}
    events={events[ROOM.A]}
  />
  <Room
    roomname="B"
    roomsrc={roomEmpty}
    events={events[ROOM.B]}
  />
  <Room
    roomname="C"
    roomsrc={roomEmpty}
    events={events[ROOM.C]}
  />
  <Room
    roomname="D"
    roomsrc={roomEmpty}
    events={events[ROOM.D]}
  />
  <Room
    roomname="E"
    roomsrc={roomEmpty}
    events={events[ROOM.E]}
  />
  <Room
    roomname="F"
    roomsrc={roomEmpty}
    events={events[ROOM.F]}
  />
  <Room
    roomname="G"
    roomsrc={roomEmpty}
    events={events[ROOM.G]}
  />
</Schedule>

